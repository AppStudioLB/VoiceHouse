{"version":3,"sources":["modules/RTCModule.js","config.js","modules/FirebaseModule.js","VideoChat.js","VideoChatContainer.js","App.js","serviceWorker.js","index.js"],"names":["createOffer","connection","localStream","userToCall","doOffer","database","username","a","addStream","offer","setLocalDescription","console","error","initiateLocalStream","navigator","mediaDevices","getUserMedia","video","audio","stream","initiateConnection","conn","RTCPeerConnection","iceServers","urls","listenToConnectionEvents","remoteUsername","remoteVideoRef","doCandidate","onicecandidate","event","candidate","ontrack","e","srcObject","streams","sendAnswer","notif","doAnswer","JSON","parse","setRemoteDescription","createAnswer","answer","from","config","apiKey","authDomain","databaseURL","projectId","storageBucket","messagingSenderId","appId","doLogin","handleUpdate","ref","remove","on","snapshot","exists","val","to","set","type","stringify","update","VideoChat","props","onLoginClicked","onLogin","state","setState","isLoggedIn","onStartCallClicked","startCall","renderVideos","className","classnames","active","setLocalVideoRef","autoPlay","playsInline","connectedUser","setRemoteVideoRef","renderForms","key","value","onChange","target","onClick","id","this","React","Component","VideoChatContainer","componentDidMount","firebase","initializeApp","localVideoRef","localConnection","yourConn","addIceCandidate","RTCIceCandidate","addCandidate","createRef","nextProps","nextState","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.bc44f814.chunk.js","sourcesContent":["\nexport const createOffer = async (connection, localStream, userToCall, doOffer, database, username) => {\n  try {\n    connection.addStream(localStream)\n\n    const offer = await connection.createOffer()\n    await connection.setLocalDescription(offer)\n\n    doOffer(userToCall, offer, database, username)\n  } catch (exception) {\n    console.error(exception)\n  }\n}\n\nexport const initiateLocalStream = async () => {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: true,\n      audio: true\n    })\n    return stream\n  } catch (exception) {\n    console.error(exception)\n  }\n}\nexport const initiateConnection = async () => {\n  try {\n    // using Google public stun server\n    var configuration = {\n      iceServers: [{ urls: 'stun:stun2.1.google.com:19302' }]\n    }\n\n    const conn = new RTCPeerConnection(configuration)\n\n    return conn\n  } catch (exception) {\n    console.error(exception)\n  }\n}\n\nexport const listenToConnectionEvents = (conn, username, remoteUsername, database, remoteVideoRef, doCandidate) => {\n  conn.onicecandidate = function (event) {\n    if (event.candidate) {\n      doCandidate(remoteUsername, event.candidate, database, username)\n    }\n  }\n\n  // when a remote user adds stream to the peer connection, we display it\n  conn.ontrack = function (e) {\n    if (remoteVideoRef.srcObject !== e.streams[0]) {\n      remoteVideoRef.srcObject = e.streams[0]\n    }\n  }\n}\n\nexport const sendAnswer = async (conn, localStream, notif, doAnswer, database, username) => {\n  try {\n    conn.addStream(localStream)\n\n    const offer = JSON.parse(notif.offer)\n    conn.setRemoteDescription(offer)\n\n    // create an answer to an offer\n    const answer = await conn.createAnswer()\n    conn.setLocalDescription(answer)\n\n    doAnswer(notif.from, answer, database, username)\n  } catch (exception) {\n    console.error(exception)\n  }\n}\n\nexport const startCall = (yourConn, notif) => {\n  const answer = JSON.parse(notif.answer)\n  yourConn.setRemoteDescription(answer)\n}\n\nexport const addCandidate = (yourConn, notif) => {\n  // apply the new received candidate to the connection\n  const candidate = JSON.parse(notif.candidate)\n  yourConn.addIceCandidate(new RTCIceCandidate(candidate))\n}\n","const config = {\n  apiKey: 'AIzaSyConcvi0z09NQwb_qWx9e91oWjb3XJtmp8',\n  authDomain: 'voice-house-16837.firebaseapp.com',\n  databaseURL: 'https://voice-house-16837-default-rtdb.firebaseio.com/',\n  projectId: 'voice-house-16837',\n  storageBucket: 'voice-house-16837.appspot.com',\n  messagingSenderId: '834484574470',\n  appId: '1:834484574470:web:efae01fe37ac190c58e687'\n}\n\nexport default config\n","\nexport const doLogin = async (username, database, handleUpdate) => {\n  await database.ref('/notifs/' + username).remove()\n  database.ref('/notifs/' + username).on('value', snapshot => {\n    snapshot.exists() && handleUpdate(snapshot.val(), username)\n  })\n}\n\nexport const doOffer = async (to, offer, database, username) => {\n  await database.ref('/notifs/' + to).set({\n    type: 'offer',\n    from: username,\n    offer: JSON.stringify(offer)\n  })\n}\n\nexport const doAnswer = async (to, answer, database, username) => {\n  await database.ref('/notifs/' + to).update({\n    type: 'answer',\n    from: username,\n    answer: JSON.stringify(answer)\n  })\n}\n\nexport const doLeaveNotif = async (to, database, username) => {\n  await database.ref('/notifs/' + to).update({\n    type: 'leave',\n    from: username\n  })\n}\n\nexport const doCandidate = async (to, candidate, database, username) => {\n  // send the new candiate to the peer\n  await database.ref('/notifs/' + to).update({\n    type: 'candidate',\n    from: username,\n    candidate: JSON.stringify(candidate)\n  })\n}\n","import React from 'react'\nimport './App.css'\nimport 'firebase/database'\nimport classnames from 'classnames'\n\nexport default class VideoChat extends React.Component {\n  constructor (props) {\n    super(props)\n    this.state = {\n      isLoggedIn: false,\n      userToCall: null,\n      username: null\n    }\n  }\n\n  onLoginClicked = async () => {\n    await this.props.onLogin(this.state.username)\n    this.setState({\n      isLoggedIn: true\n    })\n  }\n\n  onStartCallClicked = () => {\n    this.props.startCall(this.state.username, this.state.userToCall)\n  }\n\n  renderVideos = () => {\n    return <div className={classnames('videos', { active: this.state.isLoggedIn })}>\n      <div>\n        <label>{this.state.username}</label>\n\n        <video ref={this.props.setLocalVideoRef} autoPlay playsInline></video>\n      </div>\n      <div>\n        <label>{this.props.connectedUser}</label>\n        <video ref={this.props.setRemoteVideoRef} autoPlay playsInline></video>\n      </div>\n\n    </div>\n  }\n\n  renderForms = () => {\n    return this.state.isLoggedIn\n      ? <div key='a' className='form'>\n        <label>Call to</label>\n        <input value={this.state.userToCall} type=\"text\" onChange={e => this.setState({ userToCall: e.target.value })} />\n        <button onClick={this.onStartCallClicked} id=\"call-btn\" className=\"btn btn-primary\">Call</button>\n\n      </div>\n      : <div key='b' className='form'>\n        <label>Type a name</label>\n        <input value={this.state.username} type=\"text\" onChange={e => this.setState({ username: e.target.value })} />\n\n        <button onClick={this.onLoginClicked} id=\"login-btn\" className=\"btn btn-primary\">Login</button>\n\n      </div>\n  }\n\n  render () {\n    return <section id=\"container\">\n      {this.props.connectedUser ? null : this.renderForms()}\n\n      {this.renderVideos()}\n\n    </section>\n  }\n}\n","import React from 'react'\nimport './App.css'\nimport { createOffer, initiateConnection, startCall, sendAnswer, addCandidate, initiateLocalStream, listenToConnectionEvents } from './modules/RTCModule'\nimport firebase from 'firebase/app'\nimport 'firebase/database'\nimport config from './config'\nimport { doOffer, doAnswer, doLogin, doCandidate } from './modules/FirebaseModule'\nimport 'webrtc-adapter'\nimport VideoChat from './VideoChat'\n\nclass VideoChatContainer extends React.Component {\n  constructor (props) {\n    super(props)\n    this.state = {\n      database: null,\n      connectedUser: null,\n      localStream: null,\n      localConnection: null\n    }\n    this.localVideoRef = React.createRef()\n    this.remoteVideoRef = React.createRef()\n  }\n\n    componentDidMount = async () => {\n      firebase.initializeApp(config)\n\n      // getting local video stream\n      const localStream = await initiateLocalStream()\n      this.localVideoRef.srcObject = localStream\n\n      const localConnection = await initiateConnection()\n\n      this.setState({\n        database: firebase.database(),\n        localStream,\n        localConnection\n      })\n    }\n\n    shouldComponentUpdate (nextProps, nextState) {\n      if (this.state.database !== nextState.database) {\n        return false\n      }\n      if (this.state.localStream !== nextState.localStream) {\n        return false\n      }\n      if (this.state.localConnection !== nextState.localConnection) {\n        return false\n      }\n\n      return true\n    }\n\n    startCall = async (username, userToCall) => {\n      const { localConnection, database, localStream } = this.state\n      listenToConnectionEvents(localConnection, username, userToCall, database, this.remoteVideoRef, doCandidate)\n      // create an offer\n      createOffer(localConnection, localStream, userToCall, doOffer, database, username)\n    }\n\n    onLogin = async (username) => {\n      return await doLogin(username, this.state.database, this.handleUpdate)\n    }\n\n    setLocalVideoRef = ref => {\n      this.localVideoRef = ref\n    }\n\n    setRemoteVideoRef = ref => {\n      this.remoteVideoRef = ref\n    }\n\n    handleUpdate = (notif, username) => {\n      const { localConnection, database, localStream } = this.state\n\n      if (notif) {\n        switch (notif.type) {\n          case 'offer':\n            this.setState({\n              connectedUser: notif.from\n            })\n\n            listenToConnectionEvents(localConnection, username, notif.from, database, this.remoteVideoRef, doCandidate)\n\n            sendAnswer(localConnection, localStream, notif, doAnswer, database, username)\n            break\n          case 'answer':\n\n            this.setState({\n              connectedUser: notif.from\n            })\n            startCall(localConnection, notif)\n            break\n          case 'candidate':\n            addCandidate(localConnection, notif)\n            break\n          default:\n            break\n        }\n      }\n    }\n\n    render () {\n      return <VideoChat\n        startCall={this.startCall}\n        onLogin={this.onLogin}\n        setLocalVideoRef={this.setLocalVideoRef}\n        setRemoteVideoRef={this.setRemoteVideoRef}\n        connectedUser={this.state.connectedUser}\n      />\n    }\n}\n\nexport default VideoChatContainer\n","import React from 'react'\nimport './App.css'\nimport VideoChatContainer from './VideoChatContainer'\n\nfunction App () {\n  return (\n    <div className='app'>\n      <h1>React Video Chat App</h1>\n      <h2>WebRTC + Firebase</h2>\n      <VideoChatContainer/>\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}